From fb4b727d0488bc0a5f0fd91437bcc8a92079ee38 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Wed, 8 May 2019 18:58:12 +0000
Subject: [PATCH 1/3] windowing/gbm: add GetConnector method

---
 xbmc/windowing/gbm/DRMUtils.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/windowing/gbm/DRMUtils.h b/xbmc/windowing/gbm/DRMUtils.h
index 6d6275d31bf9..2aa27e224e7e 100644
--- a/xbmc/windowing/gbm/DRMUtils.h
+++ b/xbmc/windowing/gbm/DRMUtils.h
@@ -109,6 +109,7 @@ class CDRMUtils
   std::vector<uint64_t> *GetVideoPlaneModifiersForFormat(uint32_t format) { return &m_video_plane->modifiers_map[format]; }
   std::vector<uint64_t> *GetGuiPlaneModifiersForFormat(uint32_t format) { return &m_gui_plane->modifiers_map[format]; }
   struct crtc* GetCrtc() const { return m_crtc; }
+  struct connector* GetConnector() const { return m_connector; }
 
   virtual RESOLUTION_INFO GetCurrentMode();
   virtual std::vector<RESOLUTION_INFO> GetModes();

From 2f59ec96a6fd8b7797db906449f5fbf918ad4567 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Wed, 8 May 2019 18:58:12 +0000
Subject: [PATCH 2/3] VideoLayerBridgeDRMPRIME: set HDR metadata

---
 .../Process/gbm/VideoBufferDRMPRIME.cpp       | 26 +++++++++
 .../Process/gbm/VideoBufferDRMPRIME.h         | 28 +++++++++
 .../HwDecRender/VideoLayerBridgeDRMPRIME.cpp  | 58 +++++++++++++++++++
 .../HwDecRender/VideoLayerBridgeDRMPRIME.h    | 29 ++++++++++
 4 files changed, 141 insertions(+)

diff --git a/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.cpp b/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.cpp
index 719f0185bc04..4232251858ec 100644
--- a/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.cpp
@@ -78,6 +78,32 @@ int CVideoBufferDRMPRIME::GetColorRange() const
   }
 }
 
+uint8_t CVideoBufferDRMPRIME::GetEOTF() const
+{
+  switch (m_pFrame->color_trc)
+  {
+  case AVCOL_TRC_SMPTE2084:
+    return HDMI_EOTF_SMPTE_ST2084;
+  case AVCOL_TRC_ARIB_STD_B67:
+  case AVCOL_TRC_BT2020_10:
+    return HDMI_EOTF_BT_2100_HLG;
+  default:
+    return HDMI_EOTF_TRADITIONAL_GAMMA_SDR;
+  }
+}
+
+AVMasteringDisplayMetadata* CVideoBufferDRMPRIME::GetMasteringDisplayMetadata() const
+{
+  AVFrameSideData* sd = av_frame_get_side_data(m_pFrame, AV_FRAME_DATA_MASTERING_DISPLAY_METADATA);
+  return (sd && sd->data) ? reinterpret_cast<AVMasteringDisplayMetadata*>(sd->data) : nullptr;
+}
+
+AVContentLightMetadata* CVideoBufferDRMPRIME::GetContentLightMetadata() const
+{
+  AVFrameSideData* sd = av_frame_get_side_data(m_pFrame, AV_FRAME_DATA_CONTENT_LIGHT_LEVEL);
+  return (sd && sd->data) ? reinterpret_cast<AVContentLightMetadata*>(sd->data) : nullptr;
+}
+
 bool CVideoBufferDRMPRIME::IsValid() const
 {
   AVDRMFrameDescriptor* descriptor = GetDescriptor();
diff --git a/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h b/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h
index 643395a6818a..972e77bece8e 100644
--- a/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h
@@ -14,6 +14,7 @@ extern "C"
 {
 #include <libavutil/frame.h>
 #include <libavutil/hwcontext_drm.h>
+#include <libavutil/mastering_display_metadata.h>
 }
 
 // Color enums is copied from linux include/drm/drm_color_mgmt.h (strangely not part of uapi)
@@ -28,6 +29,18 @@ enum drm_color_range
   DRM_COLOR_YCBCR_LIMITED_RANGE,
   DRM_COLOR_YCBCR_FULL_RANGE,
 };
+// HDR enums is copied from linux include/linux/hdmi.h (strangely not part of uapi)
+enum hdmi_metadata_type
+{
+  HDMI_STATIC_METADATA_TYPE1 = 1,
+};
+enum hdmi_eotf
+{
+  HDMI_EOTF_TRADITIONAL_GAMMA_SDR,
+  HDMI_EOTF_TRADITIONAL_GAMMA_HDR,
+  HDMI_EOTF_SMPTE_ST2084,
+  HDMI_EOTF_BT_2100_HLG,
+};
 
 class IVideoBufferDRMPRIME : public CVideoBuffer
 {
@@ -46,6 +59,18 @@ class IVideoBufferDRMPRIME : public CVideoBuffer
   {
     return DRM_COLOR_YCBCR_LIMITED_RANGE;
   };
+  virtual uint8_t GetEOTF() const
+  {
+    return 0;
+  };
+  virtual AVMasteringDisplayMetadata* GetMasteringDisplayMetadata() const
+  {
+    return nullptr;
+  };
+  virtual AVContentLightMetadata* GetContentLightMetadata() const
+  {
+    return nullptr;
+  };
 
   virtual bool IsValid() const
   {
@@ -86,6 +111,9 @@ class CVideoBufferDRMPRIME : public IVideoBufferDRMPRIME
   }
   int GetColorEncoding() const override;
   int GetColorRange() const override;
+  uint8_t GetEOTF() const override;
+  AVMasteringDisplayMetadata* GetMasteringDisplayMetadata() const override;
+  AVContentLightMetadata* GetContentLightMetadata() const override;
 
   bool IsValid() const override;
 
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.cpp
index 3277d3667cf2..950f0c2c2825 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.cpp
@@ -31,6 +31,18 @@ void CVideoLayerBridgeDRMPRIME::Disable()
   struct plane* plane = m_DRM->GetVideoPlane();
   m_DRM->AddProperty(plane, "FB_ID", 0);
   m_DRM->AddProperty(plane, "CRTC_ID", 0);
+
+  // disable HDR metadata
+  struct connector* connector = m_DRM->GetConnector();
+  if (m_DRM->SupportsProperty(connector, "HDR_OUTPUT_METADATA"))
+  {
+    m_DRM->AddProperty(connector, "HDR_OUTPUT_METADATA", 0);
+    m_DRM->SetActive(true);
+
+    if (m_hdr_blob_id)
+      drmModeDestroyPropertyBlob(m_DRM->GetFileDescriptor(), m_hdr_blob_id);
+    m_hdr_blob_id = 0;
+  }
 }
 
 void CVideoLayerBridgeDRMPRIME::Acquire(IVideoBufferDRMPRIME* buffer)
@@ -141,6 +153,52 @@ void CVideoLayerBridgeDRMPRIME::Configure(IVideoBufferDRMPRIME* buffer)
     m_DRM->AddProperty(plane, "COLOR_ENCODING", buffer->GetColorEncoding());
     m_DRM->AddProperty(plane, "COLOR_RANGE", buffer->GetColorRange());
   }
+
+  struct connector* connector = m_DRM->GetConnector();
+  if (m_DRM->SupportsProperty(connector, "HDR_OUTPUT_METADATA"))
+  {
+    m_hdr_metadata.metadata_type = HDMI_STATIC_METADATA_TYPE1;
+    m_hdr_metadata.hdmi_metadata_type1 = {
+      .eotf = buffer->GetEOTF(),
+      .metadata_type = HDMI_STATIC_METADATA_TYPE1,
+    };
+
+    if (m_hdr_blob_id)
+      drmModeDestroyPropertyBlob(m_DRM->GetFileDescriptor(), m_hdr_blob_id);
+    m_hdr_blob_id = 0;
+
+    if (m_hdr_metadata.hdmi_metadata_type1.eotf)
+    {
+      AVMasteringDisplayMetadata* mdmd = buffer->GetMasteringDisplayMetadata();
+      if (mdmd && mdmd->has_primaries)
+      {
+        for (int i = 0; i < 3; i++)
+        {
+          m_hdr_metadata.hdmi_metadata_type1.display_primaries[i].x = std::round(av_q2d(mdmd->display_primaries[i][0]) * 50000.0);
+          m_hdr_metadata.hdmi_metadata_type1.display_primaries[i].y = std::round(av_q2d(mdmd->display_primaries[i][1]) * 50000.0);
+        }
+        m_hdr_metadata.hdmi_metadata_type1.white_point.x = std::round(av_q2d(mdmd->white_point[0]) * 50000.0);
+        m_hdr_metadata.hdmi_metadata_type1.white_point.y = std::round(av_q2d(mdmd->white_point[1]) * 50000.0);
+      }
+      if (mdmd && mdmd->has_luminance)
+      {
+        m_hdr_metadata.hdmi_metadata_type1.max_display_mastering_luminance = std::round(av_q2d(mdmd->max_luminance));
+        m_hdr_metadata.hdmi_metadata_type1.min_display_mastering_luminance = std::round(av_q2d(mdmd->min_luminance) * 10000.0);
+      }
+
+      AVContentLightMetadata* clmd = buffer->GetContentLightMetadata();
+      if (clmd)
+      {
+        m_hdr_metadata.hdmi_metadata_type1.max_cll = clmd->MaxCLL;
+        m_hdr_metadata.hdmi_metadata_type1.max_fall = clmd->MaxFALL;
+      }
+
+      drmModeCreatePropertyBlob(m_DRM->GetFileDescriptor(), &m_hdr_metadata, sizeof(m_hdr_metadata), &m_hdr_blob_id);
+    }
+
+    m_DRM->AddProperty(connector, "HDR_OUTPUT_METADATA", m_hdr_blob_id);
+    m_DRM->SetActive(true);
+  }
 }
 
 void CVideoLayerBridgeDRMPRIME::SetVideoPlane(IVideoBufferDRMPRIME* buffer, const CRect& destRect)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.h b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.h
index ade17ac0c3d4..aed6f54bfb8c 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.h
@@ -13,6 +13,32 @@
 
 #include <memory>
 
+// HDR structs copied from HDR patchset, should be removed before merge
+struct hdr_metadata_infoframe
+{
+  uint8_t eotf;
+  uint8_t metadata_type;
+  struct
+  {
+    uint16_t x, y;
+  } display_primaries[3];
+  struct
+  {
+    uint16_t x, y;
+  } white_point;
+  uint16_t max_display_mastering_luminance;
+  uint16_t min_display_mastering_luminance;
+  uint16_t max_cll;
+  uint16_t max_fall;
+};
+struct hdr_output_metadata
+{
+  uint32_t metadata_type;
+  union {
+    struct hdr_metadata_infoframe hdmi_metadata_type1;
+  };
+};
+
 namespace KODI
 {
 namespace WINDOWING
@@ -49,4 +75,7 @@ class CVideoLayerBridgeDRMPRIME
 
   IVideoBufferDRMPRIME* m_buffer = nullptr;
   IVideoBufferDRMPRIME* m_prev_buffer = nullptr;
+
+  uint32_t m_hdr_blob_id = 0;
+  struct hdr_output_metadata m_hdr_metadata = {};
 };

From 1076eb3bbdd8bd116ae589af3618a27949e79cf7 Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Wed, 8 May 2019 19:25:40 +0000
Subject: [PATCH 3/3] fixup! VideoLayerBridgeDRMPRIME: set HDR metadata

---
 xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h b/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h
index 972e77bece8e..0cb3c91dd735 100644
--- a/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h
@@ -61,7 +61,7 @@ class IVideoBufferDRMPRIME : public CVideoBuffer
   };
   virtual uint8_t GetEOTF() const
   {
-    return 0;
+    return HDMI_EOTF_TRADITIONAL_GAMMA_SDR;
   };
   virtual AVMasteringDisplayMetadata* GetMasteringDisplayMetadata() const
   {
